nextflow.enable.dsl=2

fun = [
  'name': 'poc',
  'container': 'poc',
  'containerTag': 'latest',
  'containerRegistry': '',
  'command': 'poc',
  'arguments': [
    [
      'name': 'input_one',
      'otype': '--',
      'required': true,
      'type': 'file',
      'direction': 'Input',
      'multiple': false,
      'multiple_sep': ':',
      'example': 'input.txt',
      'ext': 'txt',
      'description': 'Input one.'
    ],
    [
      'name': 'input_multi',
      'otype': '--',
      'required': true,
      'type': 'file',
      'direction': 'Input',
      'multiple': true,
      'multiple_sep': ':',
      'example': 'input.txt',
      'ext': 'txt',
      'description': 'Input multiple.'
    ],
    [
      'name': 'input_opt',
      'otype': '--',
      'required': false,
      'type': 'file',
      'direction': 'Input',
      'multiple': false,
      'multiple_sep': ':',
      'example': 'input.txt',
      'ext': 'txt',
      'description': 'Input optional.'
    ],
    [
      'name': 'output_one',
      'otype': '--',
      'required': true,
      'type': 'file',
      'direction': 'Output',
      'multiple': false,
      'multiple_sep': ':',
      'example': 'output.txt',
      'default': '$id.$key.output_one.txt',
      'ext': 'txt',
      'description': 'Output one.'
    ],
    [
      'name': 'output_multi',
      'otype': '--',
      'required': true,
      'type': 'file',
      'direction': 'Output',
      'multiple': true,
      'multiple_sep': ':',
      'example': 'output.txt',
      'default': '$id.$key.output_multi.txt',
      'ext': 'txt',
      'description': 'Output multiple.'
    ],
    [
      'name': 'output_opt',
      'otype': '--',
      'required': false,
      'type': 'file',
      'direction': 'Output',
      'multiple': false,
      'multiple_sep': ':',
      'example': 'output.txt',
      'default': '$id.$key.output_default.txt',
      'ext': 'txt',
      'description': 'Output optional.'
    ],
    [
      'name': 'string',
      'otype': '--',
      'required': false,
      'type': 'string',
      'direction': 'Input',
      'multiple': false,
      'multiple_sep': ':',
      'default': 'A string',
      'description': 'String'
    ],
    [
      'name': 'integer',
      'otype': '--',
      'required': false,
      'type': 'integer',
      'direction': 'Input',
      'multiple': false,
      'multiple_sep': ':',
      'default': '10',
      'description': 'Integer'
    ],
    [
      'name': 'double',
      'otype': '--',
      'required': false,
      'type': 'double',
      'direction': 'Input',
      'multiple': false,
      'multiple_sep': ':',
      'default': '5.5',
      'description': 'Double'
    ],
    [
      'name': 'flag_true',
      'otype': '--',
      'required': false,
      'type': 'boolean_true',
      'direction': 'Input',
      'multiple': false,
      'multiple_sep': ':',
      'default': 'false',
      'description': 'Flag true'
    ],
    [
      'name': 'flag_false',
      'otype': '--',
      'required': false,
      'type': 'boolean_false',
      'direction': 'Input',
      'multiple': false,
      'multiple_sep': ':',
      'default': 'true',
      'description': 'Flag false'
    ],
    [
      'name': 'boolean',
      'otype': '--',
      'required': false,
      'type': 'boolean',
      'direction': 'Input',
      'multiple': false,
      'multiple_sep': ':',
      'default': 'true',
      'description': 'Boolean'
    ]
  ]
]



// todo: add more directives 
// https://www.nextflow.io/docs/latest/process.html#directives
// e.g. time
process poc_process {
  tag "${processArgs.id}"
  echo { processArgs.echo }
  // label "${processArgs.label}"
  queue "${processArgs.queue}"
  maxForks { processArgs.maxForks }
  cache "deep"
  stageInMode "symlink"
  container "${processArgs.container}"
  publishDir "${processArgs.publishDir}", mode: "${processArgs.publishMode}", overwrite: true, enabled: { "${processArgs.publish}" }
  
  input:
    tuple path(paths), val(args), val(processArgs)
  output:
    tuple val("${processArgs.id}"), path("${args.output_one}"), path("${args.output_multi}")
  stub:
    """
    ...
    """
  script:
  def parInject = args.collect{ key, value ->
    "VIASH_PAR_${key.toUpperCase()}=\"$value\""
  }.join("\n")
  println("processArgs.publish: ${processArgs.publish}")
"""
# TO DO: VIASH_TEMP
# TO DO: VIASH_RESOURCES_DIR
# TO DO: optional args
VIASH_RESOURCES_DIR="."

$parInject

cat << VIASHEOF | bash
set -e
tempscript=mytemporaryscript.R
cat > "\\\$tempscript" << 'VIASHMAIN'
# The following code has been auto-generated by Viash.
par <- list(
  "input_one" = \$( if [ ! -z \${VIASH_PAR_INPUT_ONE+x} ]; then echo "'\$VIASH_PAR_INPUT_ONE'"; else echo NULL; fi ),
  "input_multi" = \$( if [ ! -z \${VIASH_PAR_INPUT_MULTI+x} ]; then echo "strsplit('\$VIASH_PAR_INPUT_MULTI', split = ':')[[1]]"; else echo NULL; fi ),
  "input_opt" = \$( if [ ! -z \${VIASH_PAR_INPUT_OPT2+x} ]; then echo "'\$VIASH_PAR_INPUT_OPT2'"; else echo NULL; fi ),
  "output_one" = \$( if [ ! -z \${VIASH_PAR_OUTPUT_ONE+x} ]; then echo "'\$VIASH_PAR_OUTPUT_ONE'"; else echo NULL; fi ),
  "output_multi" = \$( if [ ! -z \${VIASH_PAR_OUTPUT_MULTI+x} ]; then echo "strsplit('\$VIASH_PAR_OUTPUT_MULTI', split = ':')[[1]]"; else echo NULL; fi ),
  "output_opt2" = \$( if [ ! -z \${VIASH_PAR_OUTPUT_OPT2+x} ]; then echo "'\$VIASH_PAR_OUTPUT_OPT2'"; else echo NULL; fi ),
  "string" = \$( if [ ! -z \${VIASH_PAR_STRING+x} ]; then echo "'\$VIASH_PAR_STRING'"; else echo NULL; fi ),
  "integer" = \$( if [ ! -z \${VIASH_PAR_INTEGER+x} ]; then echo "as.integer(\$VIASH_PAR_INTEGER)"; else echo NULL; fi ),
  "double" = \$( if [ ! -z \${VIASH_PAR_DOUBLE+x} ]; then echo "as.numeric(\$VIASH_PAR_DOUBLE)"; else echo NULL; fi ),
  "flag_true" = \$( if [ ! -z \${VIASH_PAR_FLAG_TRUE+x} ]; then echo "as.logical(toupper('\$VIASH_PAR_FLAG_TRUE'))"; else echo NULL; fi ),
  "flag_false" = \$( if [ ! -z \${VIASH_PAR_FLAG_FALSE+x} ]; then echo "as.logical(toupper('\$VIASH_PAR_FLAG_FALSE'))"; else echo NULL; fi ),
  "boolean" = \$( if [ ! -z \${VIASH_PAR_BOOLEAN+x} ]; then echo "as.logical(toupper('\$VIASH_PAR_BOOLEAN'))"; else echo NULL; fi )
)

resources_dir = "\$VIASH_RESOURCES_DIR"

print(par)
readr::write_lines("foo", par\\\$output_one)
readr::write_lines("bar", par\\\$output_multi)

VIASHMAIN

Rscript "\\\$tempscript"
VIASHEOF
"""
}


defaultProcArgs = [
  echo: false,
  key: "poc",
  label: "",
  queue: "",
  publish: false, 
  publishDir: ".",
  publishMode: "copy",
  container: "rocker/tidyverse:4.0.5", 
  map: null,
  mapId: { it -> it[0] },
  mapData: { it -> it[1] },
  // TODO: map0, map1, map2, map3, ...?
  filter: { it -> true },
  mapOutput : {it -> it},
  filterOutput : {it -> true},
  args: [:]
]

def poc(Map args = [:]) {
  def processArgs = defaultProcArgs + args

  workflow poc_wf_instance {
    take:
    input_

    main:
      def poc_proc = poc_process.cloneWithName(processArgs.key + "_process")

    output_= input_
        | map{ id_input_obj ->
          // TODO: add debug option to see what goes in and out of the workflow
          if (processArgs.map) {
            id_input_obj = processArgs.map(id_input_obj)
          }
          
          // TODO: add checks on id_input_obj to see if it is in the right format
          def id = id_input_obj[0]
          def data = id_input_obj[1]

          // fetch default params from functionality
          def defaultArgs = fun.arguments.findAll{ it.default }.collectEntries {
            [ it.name, it.default ]
          }

          // fetch overrides in params
          def paramArgs = fun.arguments
            .findAll { params.containsKey(processArgs.key + "__" + it.name) }
            .collectEntries { [ it.name, params[processArgs.key + "__" + it.name] ] }
          
          // fetch overrides in data
          def dataArgs = fun.arguments
            .findAll { data.containsKey(it.name) }
            .collectEntries { [ it.name, data[it.name] ] }
          
          // combine params
          def combinedArgs = defaultArgs + paramArgs + processArgs.args + dataArgs
          def passProcessArgs = ["echo", "label", "queue", "publish", "publishDir", "publishMode", "container"]
          def combinedProcessArgs = processArgs.subMap(passProcessArgs) + [ id: id ]

          def combinedArgs2 = fun.arguments
            .findAll { combinedArgs.containsKey(it.name) }
            .collectEntries { par ->
              def parVal = combinedArgs[par.name]
              if (par.direction.toLowerCase() == "output" && par.type == "file") {
                def newVal = parVal.replaceAll('\\$id', id).replaceAll('\\$key', processArgs.key)
                [par.name, newVal]
              } else {
                [par.name, parVal]
              }
              
            }

          // TODO: check whether required arguments exist
          // TODO: check whether parameters have the right type

          def paths = [ combinedArgs2.input_one, combinedArgs2.input_multi ]
          
          // todo: add passthrough for other tuple items
          def out = [ paths, combinedArgs2, combinedProcessArgs ]

          out
        }
        | poc_proc
        | map { output ->
          [ output[0], [ output_one: output[1], output_multi: output[2] ] ]
        }

    emit:
    output_
  }

  return poc_wf_instance
}
