nextflow.enable.dsl=2

fun = [
  "name": "poc",
  "container": "poc",
  "containerTag": "latest",
  "containerRegistry": "",
  "command": "poc",
  "arguments": [
    [
      "name": "input_one",
      "otype": "--",
      "required": true,
      "type": "file",
      "direction": "Input",
      "multiple": false,
      "multiple_sep": ":",
      "example": "input.txt",
      "ext": "txt",
      "description": "Input one."
    ],
    [
      "name": "input_multi",
      "otype": "--",
      "required": true,
      "type": "file",
      "direction": "Input",
      "multiple": true,
      "multiple_sep": ":",
      "example": "input.txt",
      "ext": "txt",
      "description": "Input multiple."
    ],
    [
      "name": "input_opt",
      "otype": "--",
      "required": false,
      "type": "file",
      "direction": "Input",
      "multiple": false,
      "multiple_sep": ":",
      "example": "input.txt",
      "ext": "txt",
      "description": "Input optional."
    ],
    [
      "name": "output_one",
      "otype": "--",
      "required": true,
      "type": "file",
      "direction": "Output",
      "multiple": false,
      "multiple_sep": ":",
      "example": "output.txt",
      "default": "id.poc.output_one.txt",
      "ext": "txt",
      "description": "Output one."
    ],
    [
      "name": "output_multi",
      "otype": "--",
      "required": true,
      "type": "file",
      "direction": "Output",
      "multiple": true,
      "multiple_sep": ":",
      "example": "output.txt",
      "default": "id.poc.output_multi.txt",
      "ext": "txt",
      "description": "Output multiple."
    ],
    [
      "name": "output_opt",
      "otype": "--",
      "required": false,
      "type": "file",
      "direction": "Output",
      "multiple": false,
      "multiple_sep": ":",
      "example": "output.txt",
      "default": "id.poc.output_default.txt",
      "ext": "txt",
      "description": "Output optional."
    ],
    [
      "name": "string",
      "otype": "--",
      "required": false,
      "type": "string",
      "direction": "Input",
      "multiple": false,
      "multiple_sep": ":",
      "default": "A string",
      "description": "String"
    ],
    [
      "name": "integer",
      "otype": "--",
      "required": false,
      "type": "integer",
      "direction": "Input",
      "multiple": false,
      "multiple_sep": ":",
      "default": "10",
      "description": "Integer"
    ],
    [
      "name": "double",
      "otype": "--",
      "required": false,
      "type": "double",
      "direction": "Input",
      "multiple": false,
      "multiple_sep": ":",
      "default": "5.5",
      "description": "Double"
    ],
    [
      "name": "flag_true",
      "otype": "--",
      "required": false,
      "type": "boolean_true",
      "direction": "Input",
      "multiple": false,
      "multiple_sep": ":",
      "default": "false",
      "description": "Flag true"
    ],
    [
      "name": "flag_false",
      "otype": "--",
      "required": false,
      "type": "boolean_false",
      "direction": "Input",
      "multiple": false,
      "multiple_sep": ":",
      "default": "true",
      "description": "Flag false"
    ],
    [
      "name": "boolean",
      "otype": "--",
      "required": false,
      "type": "boolean",
      "direction": "Input",
      "multiple": false,
      "multiple_sep": ":",
      "default": "true",
      "description": "Boolean"
    ]
  ]
]



// todo: add more directives 
// https://www.nextflow.io/docs/latest/process.html#directives
// e.g. time
process poc_process {
  tag "${processArgs.id}"
  echo { processArgs.echo }
  cache "deep"
  stageInMode "symlink"
  container "${processArgs.container}"
  publishDir "${processArgs.publishDir}", mode: 'copy', overwrite: true, enabled: { processArgs.publish }
  input:
    tuple path(paths), val(args), val(processArgs)
  output:
    tuple val("${processArgs.id}"), path("${args.output_one}"), path("${args.output_multi}")
  stub:
    """
    ...
    """
  script:
  def parInject = args.collect{ key, value ->
    "VIASH_PAR_${key.toUpperCase()}=\"$value\""
  }.join("\n")

"""
# TO DO: VIASH_TEMP
# TO DO: VIASH_RESOURCES_DIR
# TO DO: optional args
VIASH_RESOURCES_DIR="."

$parInject

cat << VIASHEOF | bash
set -e
tempscript=mytemporaryscript.R
cat > "\\\$tempscript" << 'VIASHMAIN'
# The following code has been auto-generated by Viash.
par <- list(
  "input_one" = \$( if [ ! -z \${VIASH_PAR_INPUT_ONE+x} ]; then echo "'\$VIASH_PAR_INPUT_ONE'"; else echo NULL; fi ),
  "input_multi" = \$( if [ ! -z \${VIASH_PAR_INPUT_MULTI+x} ]; then echo "strsplit('\$VIASH_PAR_INPUT_MULTI', split = ':')[[1]]"; else echo NULL; fi ),
  "input_opt" = \$( if [ ! -z \${VIASH_PAR_INPUT_OPT2+x} ]; then echo "'\$VIASH_PAR_INPUT_OPT2'"; else echo NULL; fi ),
  "output_one" = \$( if [ ! -z \${VIASH_PAR_OUTPUT_ONE+x} ]; then echo "'\$VIASH_PAR_OUTPUT_ONE'"; else echo NULL; fi ),
  "output_multi" = \$( if [ ! -z \${VIASH_PAR_OUTPUT_MULTI+x} ]; then echo "strsplit('\$VIASH_PAR_OUTPUT_MULTI', split = ':')[[1]]"; else echo NULL; fi ),
  "output_opt2" = \$( if [ ! -z \${VIASH_PAR_OUTPUT_OPT2+x} ]; then echo "'\$VIASH_PAR_OUTPUT_OPT2'"; else echo NULL; fi ),
  "string" = \$( if [ ! -z \${VIASH_PAR_STRING+x} ]; then echo "'\$VIASH_PAR_STRING'"; else echo NULL; fi ),
  "integer" = \$( if [ ! -z \${VIASH_PAR_INTEGER+x} ]; then echo "as.integer(\$VIASH_PAR_INTEGER)"; else echo NULL; fi ),
  "double" = \$( if [ ! -z \${VIASH_PAR_DOUBLE+x} ]; then echo "as.numeric(\$VIASH_PAR_DOUBLE)"; else echo NULL; fi ),
  "flag_true" = \$( if [ ! -z \${VIASH_PAR_FLAG_TRUE+x} ]; then echo "as.logical(toupper('\$VIASH_PAR_FLAG_TRUE'))"; else echo NULL; fi ),
  "flag_false" = \$( if [ ! -z \${VIASH_PAR_FLAG_FALSE+x} ]; then echo "as.logical(toupper('\$VIASH_PAR_FLAG_FALSE'))"; else echo NULL; fi ),
  "boolean" = \$( if [ ! -z \${VIASH_PAR_BOOLEAN+x} ]; then echo "as.logical(toupper('\$VIASH_PAR_BOOLEAN'))"; else echo NULL; fi )
)

resources_dir = "\$VIASH_RESOURCES_DIR"

print(par)
readr::write_lines("foo", par\\\$output_one)
readr::write_lines("bar", par\\\$output_multi)

VIASHMAIN

Rscript "\\\$tempscript"
VIASHEOF
"""
}


defaultProcArgs = [
  echo: false,
  params_key: "poc", 
  publish: false, 
  publishDir: ".", 
  container: "rocker/tidyverse:4.0.5", 
  map: { it -> it }, 
  args: [:]
]

def poc(Map args = [:]) {
  def processArgs = defaultProcArgs + args

  workflow poc_wf_instance {
    take:
    input_

    main:
      def poc_proc = poc_process.cloneWithName(processArgs.params_key + "_process")

    output_= input_
        | map{ obj ->
          // TODO: add debug option to see what goes in and out of the workflow
          
          def id_input_obj = processArgs.map(obj)
          // TODO: add checks on id_input_obj to see if it is in the right format
          def id = id_input_obj[0]
          def data = id_input_obj[1]

          // fetch default params from functionality
          def defaultArgs = fun.arguments.findAll{ it.default }.collectEntries {
            [ it.name, it.default ]
          }

          // fetch overrides in params
          def paramArgs = fun.arguments
            .findAll { params.containsKey(processArgs.params_key + "__" + it.name) }
            .collectEntries { [ it.name, params[processArgs.params_key + "__" + it.name] ] }
          
          // fetch overrides in data
          def dataArgs = fun.arguments
            .findAll { data.containsKey(it.name) }
            .collectEntries { [ it.name, data[it.name] ] }
          
          // combine params
          def combinedArgs = defaultArgs + paramArgs + processArgs.args + dataArgs
          def combinedProcessArgs = processArgs.subMap(["echo", "publish", "publishDir", "container"]) + [ id: id ]

          // TODO: check whether required arguments exist
          // TODO: check whether parameters have the right type

          def paths = [ combinedArgs.input_one, combinedArgs.input_multi ]
          
          // todo: add passthrough for other tuple items
          def out = [ paths, combinedArgs, combinedProcessArgs ]

          out
        }
        | poc_proc
        | map { output ->
          [ output[0], [ output_one: output[1], output_multi: output[2] ] ]
        }

    emit:
    output_
  }

  return poc_wf_instance
}